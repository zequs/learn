## JMM-JAVA内存模型

### 基础

#### 概念

`同步`

- 是指程序用于控制不同线程之间操作发生相对顺序的机制。

#### 并发编程分类

- 问题
  - 线程之间如何通信
    - 共享内存或消息传递
  - 线程之间如何同步
- 分类
  - 共享内存的并发模型
    - 线程之间通过写-读内存中的公共状态来隐式进行通信
  - 消息传递的并发模型
    - 明确的发送消息来显式进行通信
- `java`
  - `java`采用的共享内存模型，java线程之间的通信是隐式进行的（通过共享内存状态进行通信）。

#### java内存模型（JMM）的抽象

共享变量

- java中，所有实例域、静态域和数组元素在堆内存中，堆内存在线程之间共享，统称为共享变量

`JMM`

- java线程之间的通信是由java 内存模型（JMM）控制，JMM决定了一个线程共享变量的写入何时对另一个线程可见。
- 从抽象角度来讲，JMM决定了线程和主存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。
- JMM是一个抽象的概念，并不存在，它覆盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

#### 重排序

​		在执行程序时为了提高性能，编译期和处理器常常会对指令做重排序

分类：

- 编译器优化的重排序
  - 编译期重排序
  - 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序
- 指令并行的重排序
  - 处理器重排序
  - 现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对鹰机器指令的执行顺序
- 内存系统的重排序
  - 处理器重排序
  - 由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行
  - 理解
    - x是共享变量，r是局部变量，A，B是线程，①，②是执行顺序，x,r初始值都为0
      - ①A：x=1，②B：r=x
      - 线程A执行x=1时，可能X可能还在写缓冲区，还没刷新为主内存（x=0）时，线程B执行r=x了，但此时x还是0，看起来就像②比①先执行一样。看起来就像是乱序执行一样。

JMM控制

- 对于编译器
  - 会禁止特定类型的编译器重排序（不是所有编译器重排序都禁止）
- 对于处理器
  - 会要求java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序
- JMM属于语言级别内存模型，它确保在不同的编译器和不容的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。

#### happens-before

- 概念
  - 阐述操作之间的可见性
- 规则
  - 程序顺序规则
    - 一个线程中的每个操作，happens-before与线程中的任意后续操作
  - 监视器锁规则
    - 对一个监视器的解锁，happens-before于随后对这个监视器的加锁
  - volatile变量规则
    - 对一个volatile的写，happens-before于任意后续对这个volatile的读
  - 传递性
    - A happens-before B，且B happens-before C，那么A happens-before C。
- 注意
  - 两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行，happens-before仅仅要求前一个操作对后一个操作可见，且前一个操作按顺序排在第二个操作之前
- 作用
  - 一个happens-before规则对应于一个或多个编译器和处理器排序规则。
  - 对于程序员来说，happens-before规则简单易懂，它避免java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体表现。

### 重排序

#### 数据依赖性

两个操作访问同一个变量，且这两个操作中有一个是写操作，此时这 两个操作存在依赖性。

数据的依赖性，只针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器，不同线程之间不做考虑。

#### as-if-serial

定义

- 不管怎么排序（编译器重排序，处理器重排序），（单线程）程序的执行结果不能被改变。

#### 程序顺序规则

​		根据happens-before的传递性，A happens-before B ，B happens-before C  则A happens-before C 

#### 重排序对多线程的影响

```java
class ReadExample{
    int a = 0;
    boolean flag = false;
    
    public void write() {
        a = 1;				//1
        flag = true;		//2
    }
    
    public void read() {
        if(flag) {			//3
            int i =  a*a;	//4
        }
    }
}
```

flag是一个标记，标识变量a是否被写入，线程A首先执行write()，线程B接着执行read()。

多线程的情况下，步骤1,2可能会发生重排序。从而会导致步骤3,4的结果。