### 设计模式

#### 单例

所谓类的单例设计模式，就是采用一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。

单例模式八种方式

- 饿汉式（静态常量）
  - 优缺点说明：
    - 优点：
      - 这种写法比较简单，就是在类的装载的时候就完成了实例化，避免了线程同步问题
    - 缺点：
      - 在类装载的时候就完成了实例化，没有达到懒加载效果，如果从始至终从来没有使用过这个实例，则会造成内存的浪费
    - 这种方式基于`classloder`机制避免了多线程的同步问题，不过，instance在类装载是就实例化，在单例模式中大多数都是调用getInstance()，但是导致类装载的原因有很多种，因此不能确定有其他的方式导致类装载，这时候初始化instance就没有达到懒加载的效果。
    - 结论：这种单例方式可用，但会造成内存浪费。
- 饿汉式（静态代码块）
- 懒汉式（线程不安全）
- 懒汉式（线程安全，同步方法）
- 懒汉式（线程安全，同步代码块）
- 双重检查
- 静态内部类
- 枚举

#### 建造者模式

基本介绍

- 建造者模式又叫生成器模式，是一种对象构建模式。它可以将复杂的对象的建造过程抽象出来。使这个抽象过程的不同实现方法可以构造出不同表现的对象
- 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。
- 四个角色
  - product(产品角色)：一个具体的产品对象
  - builder(抽象建造者)：创建有一个product对象的各个部件指定接口
  - concreteBuilder(具体建造者）：实现接口，构建和装配各个部件
  - Director(指挥者)：构建一个使用build接口的对象。它主要是用于创建一个复杂的对象。他只要有两个作用，
    - 隔离客户与生产的过程 
    - 复制制造产品对象的生产过程
- 注意事项
  - 客户端不必知道产品内部组成的细节，讲产品本身与产品的创建解耦，使得相同的创建过程可以创建不同的产品对象
  - 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的建造者。用户使用不同的具体建造者可以得到不同的产品。
  - 可以更加精细的控制产品的创建过程。讲复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
  - 增加新的具体创建者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合开闭原则。
  - 建造者模式所创建的产品一般都较多的共同点，其组成部分相识，产品之间的差异很大的，则不适合此模式。因此使用范围受到一定的限制。
  - 如果产品内部变化复杂，可能会导致需要定义很多具体建造者来实现这种变化，导致系统变得很庞大，因此在这这种情况下，要考虑是否选择建造模式。
- 抽象工厂与建造者比较
  - 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的组合，采用抽象工厂模式不需要关心创建过程，只关系什么产品由什么工厂创建。而建造者模式则是要求按照指定的蓝图创建产品，它的主要目的是通过组装零配件而产生一个新产品。

#### 适配器模式 （adapter pattern）

基本介绍

- 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本接口不匹配不能一起工作的两个类可以协同工作，其别名是包装器（Wrapper）
- 适配器模式属于结构型模式
- 主要分三类：类适配器模式、对象适配器模式、接口适配器模式
  - 类适配器
    - adapter类，通过继承src（适配）类，实现dst（目标）类接口，完成src->dst的适配
- 工作原理
  - 适配器模式：将一个类的接口转换成另一个类的接口，让原本接口不兼容的类可以兼容
  - 从用户的角度看不到被适配者，是解耦的
  - 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法。
  - 用户收到反馈结果，感觉只是跟目标接口交互

#### 桥接模式

基本介绍

- 桥接模式是指：将实现与抽象放在两个不同的层次中，使两个层次可以独立改变
- 是一种结构设计模式
- 桥接模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职能，它的主要特点是把抽象与实现分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展

#### 装饰者模式(Decorator)

基本介绍

- 装饰者模式：动态的将新功能附件到对象上，在对象功能扩展方面，它比继承更有弹性，装饰者模式也遵守了开闭原则。

装饰者模式原理

- 装饰者模式就像打包一个快递
  - 主体（Component）：比如：陶瓷，衣服。被装饰者
  - 包装（Decorator）：比如报纸填充，塑料泡沫，纸板，木板。
- 如果ConcreteComponent（Component的实现）类很多，还可以设计一个缓冲层，将共有的部分提取出来。

类图

- 结构说明
  - decorator：装饰者，比如各种调料
  - component：主体
  - coffer：缓冲层

- ![1564994394140](picture\decorator.png)

#### 组合模式(Composite)

基本介绍

-  组合模式，又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次部分
- 组合模式依据树形结构来组合对象，用来表示部分以及整体的层次。
- 这种类型的设计模式属于结构模式
- 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象。

类图结构

- leaf：在组合中表示叶子节点，最后一个节点，叶子节点没有子节点
- composite：非叶子节点，用于存储子部件。
- component：为所有对象定义一个类，不管是叶子节点（最后一个节点）还是节点

解决的问题

- 当我们的要处理的对象可以生成一颗树形结构，而我们要对树上的节点和叶子节点进行操作时，它能够提供一致的方式，而不用考虑是叶子节点还是一般节点。

#### 外观模式（Facade）

基本介绍

- 外观模式也叫，过程模式，外观模式为子系统中的一组接口提供一个一致的界面，此模式定义一个高层接口，这个接口使得这一子系统更加容易使用
- 外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节

类图

- ![外观模式](picture\facade.png)

外观模式的注意事项与细节

- 外观模式对外屏蔽了子系统的细节，因此降低了客户端对子系统的复杂性
- 外观模式对客户端与子系统的耦合关系，让子系统的内部模块更易维护和扩展
- 通过合理的外观模式，可以帮我们更好的划分访问层次
- 当系统考虑使用分成设计时，可以考虑外观模式
- 在维护一个遗留的大型项目时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个facade类，来提供遗留系统的比较清晰简单的接口，让新系统与facade类交互，提高复用性
- 不能过多的不合理的使用外观模式，使用外观模式好，还是直接调用模块好，要以让系统有层次，利于维护为目的。

#### 享元模式（Flyweight）

基本介绍 

- 享元模式：也叫蝇量模式，运用共享技术有效的支持大量细粒度的对象
- 常用于系统底层开发，解决系统的性能问题。像连接池技术，里面就是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个
- 享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相识对象，需要缓冲池时。不需要总是创建对象，可以从缓冲池中拿。这样可以提高系统内存，提高性能
- 享元模式经典的场景应用就是池技术，String常量池，数据库连接池，包装类等。享元模式是池技术的重要实现方式。

类图

- ![1565072953578](picture\flyweight.png)
  - Flyweight：是抽象的享元角色，他是产品的抽象类，产品外部状态，内部状态的抽象接口
  - ConcreteFlyweight：具体享元角色，内部状态，里面的数据是可以共享的。
  - UnConcreteFlyweight：具体享元角色，外部状态，里面的内部是不共享
  - FlyweightFactory:享元工厂，用于构建一个池容器，同时提供从池中获取相应对象方法

注意事项和细节

- 在享元模式这样理解，享表示共享，元表示对象
- 系统中有大量的 对象，这些对象需要很大内存，并且对象的状态大部分可以外部分时，我们就可以考虑选用享元模式
- 用唯一标识码判断，如果在内存中有，则返回一个唯一标识的对象，用容器（map）存储
- 享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率
- 享元模式提高了系统的复杂度，需要分离出内部状态和外部状态，外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方
- 使用享元模式时，需要分离出内部状态和外部状态，并且需要有一个工厂类加以控制
- 享元模式经典的应用场景就是缓冲池的场景。比如，String常量池，数据库连接池等

#### 代理模式（Proxy）

基本介绍

- 代理模式：为一个对象提供一个替身，以控制对这个对象的访问，即通过代理对象访问目标对象。这样的好处就是，可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标的功能
- 代理模式分为静态代理和动态代理，动态代理按实现分又可分为JDK代理，cglib代理。

静态代理类图

![1565086411505](picture\proxy.png)

#### 模板模式（Template）

基本介绍

- 模板方法模式（Template method pattern）：又叫模板模式，在一个抽象类公开定义了执行它的方法模板。它的子类可以按需重写方法实现，但调用将以抽象类中定义的方法进行
- 简单来说，模板方法模式定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义改算法的某些特定步骤
- 属于行为型模式