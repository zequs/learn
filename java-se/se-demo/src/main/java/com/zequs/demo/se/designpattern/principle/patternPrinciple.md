### 设计模式-设计原则

#### 设计模式

​			**设计模式**（design pattern）是对[软件设计](https://zh.wikipedia.org/wiki/軟件設計)中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由[埃里希·伽玛](https://zh.wikipedia.org/wiki/埃里希·伽瑪)（Erich Gamma）等人在1990年代从[建筑设计](https://zh.wikipedia.org/wiki/建筑设计)领域引入到[计算机科学](https://zh.wikipedia.org/wiki/計算機科學)的。 维基百科

​		代码的复用性、稳定性、扩展 性、可读性、规范性 

#### 单一职责原则

**基本介绍**

- 对类来说的，即一个类只负责一项职责。如类A负责两个不同职责：职责1，职责2。当职责1需求变更二改变A时，可能造成职责2执行错误，所以需要讲类A的粒度分解为A1，A2。 

**注意事项**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 

- 降低类的复杂度，一个类只负责一个职责

- 提高类的可读性，可维护性

- 降低变更引起的风险

- 通常情况下，**我们应当遵守单一职责原则**，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中的方法数量足够少时，可以在方法级别上保存单一职责原则。

[代码地址](https://github.com/zequs/learn/tree/master/java-se/se-demo/src/main/java/com/zequs/demo/se/designpattern/principle/singleresponsibilityprinciple)

#### 接口隔离原则（Interface Segregation Principle）

基本介绍

- 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上

问题由来

- 类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。

处理

- 把接口I，拆成几个独立的接口。类各自实现自己需要的接口。

[代码地址](https://github.com/zequs/learn/tree/master/java-se/se-demo/src/main/java/com/zequs/demo/se/designpattern/principle/segregation)

#### 依赖倒置原则(Dependency Inversion Principle)

**定义：**

-  高层模块不应该依赖底层模块，二者都应该依赖其抽象
- 抽象不应该依赖细节，细节应该依赖抽象
- 依赖倒转的中心思想是面向接口编程 
- 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的就是接口或抽象类，细节指的实现类。
- 使用接口或抽象的目的是为了指定好规范，而不涉及任何具体的操作，把展现细节任务交给他们的实现类去完成。

注意事项

- 底层模块尽量都要有接口或抽象类，或者两者都有，程序稳定性更好。
- 变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象之间，就存在一个缓冲层，利于程序优化和扩展
- 继承时遵循里氏替换原则 

[代码地址](https://github.com/zequs/learn/tree/master/java-se/se-demo/src/main/java/com/zequs/demo/se/designpattern/principle/dependencyinversion)

#### 里氏替换原则 （Liskov Substitution Principle）

OO中继承的思考和说明

- 继承包含一种含义，父类中凡是已经实现好的方法，实际上在设定规范和契约，虽然不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已知实现的方法任意修改，就会对这个继承体系造成破坏。
- 继承在给程序设计带来便利的同时，也带来了弊端，比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合度，如果一个类被其他类继承，则当这个需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。

基本介绍

- 里氏替换原则是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。	
- 如果对每个类型为T1的对象o1，都有类型为T2的对象o2,使得以T1定义的所有程序P在所有的对象o1替换成o2时，程序P的行为没有发生改变，那么类型T2是类型T2的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类对象。

#### 迪米特法则（Law Of Demeter）

 基本介绍

- 一个对象应该对其他对象保存最少的了解

- 类与类关系越密切，耦合度越大

- 迪米特法则也称“最小知道原则”，既一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类多么复杂，都尽量把逻辑封装在类的内部，对外除了提供的public方法，不对外泄露任何信息

- 迪米特法则还有个更简单的定义：只与直接的朋友通信

- 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象有耦合关系，我们就说这两个对象之间是朋友关系，耦合的方式有很多，关联，组合，聚合等。其中，我们称出现**成员变量，方法参数，方法返回值**中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。

  - 关联：

  - 聚合：

    - 一种特殊的关联形式

  - 组合

    - 一种特殊的关联形式

    - 一种受限制的聚合形式

    - ```java
      class B {
          A a = new A();
      }
      ```

    - 组合是认为不可分割，如，人与人头，人与心脏等。

      

#### 开闭原则（Open Close Principle）

基本原则

- 开闭原则是编程中最基础，最重要的设计原则
- 一个软件实体如类，模块和函数应该对扩展开发（对提供方），对修改关闭（对使用方）。用抽象构建框架，是实现扩展细节
- 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化
- 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则

#### 参考：

[尚硅谷_韩顺平图解Java设计模式](http://www.atguigu.com/download_detail.shtml?v=202#player)

[[设计模式六大原则](https://www.cnblogs.com/duanxz/p/3653087.html)](https://www.cnblogs.com/duanxz/p/3653087.html)